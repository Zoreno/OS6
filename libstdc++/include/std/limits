/**
 * @file limits
 * @author Joakim Bertils
 * @version 0.1
 * @date 2020-07-28
 * 
 * @brief Numeric limits for C++ primitive types
 * 
 * @copyright Copyright (C) 2020,
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https: //www.gnu.org/licenses/>.
 * 
 */

#ifndef __LIMITS_
#define __LIMITS_

#pragma GCC system_header

#include <bits/c++config.hpp>

OS6STD_BEGIN_SYSTEM_HEADER

#include <bits/numeric_limits_helpers.hpp>

namespace OS6STD
{
//=========================================================================
// std::float_round_style
//=========================================================================

enum float_round_style
{
    round_indeterminate = -1,     /// Intermediate.
    round_toward_zero = 0,        /// To zero.
    round_to_nearest = 1,         /// To the nearest representable value.
    round_toward_infinity = 2,    /// To infinity.
    round_toward_neg_infinity = 3 /// To negative infinity.
};

//=========================================================================
// std::float_denorm_style
//=========================================================================

enum float_denorm_style
{
    denorm_indeterminate = -1, /// Indeterminate at compile time whether denormalized values are allowed.
    denorm_absent = 0,         /// The type does not allow denormalized values.
    denorm_present = 1         /// The type allows denormalized values.
};

//=========================================================================
// std::__numeric_limits_base
//=========================================================================

struct __numeric_limits_base
{
    static constexpr bool is_specialized = false;
    static constexpr int digits = 0;
    static constexpr int digits10 = 0;
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int radix = 0;
    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;
    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;
    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = false;
    static constexpr bool is_modulo = false;
    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

//=========================================================================
// std::numeric_limits<_Tp>
//=========================================================================

template <typename _Tp>
struct numeric_limits : public __numeric_limits_base
{
    static constexpr _Tp min() noexcept
    {
        return _Tp();
    }

    static constexpr _Tp max() noexcept
    {
        return _Tp();
    }

#if __cplusplus >= 201103L
    static constexpr _Tp lowest() noexcept
    {
        return _Tp();
    }
#endif

    static constexpr _Tp epsilon() noexcept
    {
        return _Tp();
    }

    static constexpr _Tp round_error() noexcept
    {
        return _Tp();
    }

    static constexpr _Tp infinity() noexcept
    {
        return _Tp();
    }

    static constexpr _Tp quiet_NaN() noexcept
    {
        return _Tp();
    }

    static constexpr _Tp signaling_NaN() noexcept
    {
        return _Tp();
    }

    static constexpr _Tp denorm_min() noexcept
    {
        return _Tp();
    }
};

//=========================================================================
// std::numeric_limits CV templates
//=========================================================================

template <typename _Tp>
struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp>
{
};

template <typename _Tp>
struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp>
{
};

template <typename _Tp>
struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp>
{
};

//=========================================================================
// std::numeric_limits specializations
//=========================================================================

template <>
struct numeric_limits<bool>
{
    static constexpr bool is_specialized = true;

    static constexpr bool min() noexcept
    {
        return false;
    }

    static constexpr bool max() noexcept
    {
        return true;
    }

#if __cplusplus >= 201103L
    static constexpr bool
    lowest() noexcept
    {
        return min();
    }
#endif
    static constexpr int digits = 1;
    static constexpr int digits10 = 0;
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr bool
    epsilon() noexcept { return false; }

    static constexpr bool
    round_error() noexcept { return false; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr bool
    infinity() noexcept { return false; }

    static constexpr bool
    quiet_NaN() noexcept { return false; }

    static constexpr bool
    signaling_NaN() noexcept { return false; }

    static constexpr bool
    denorm_min() noexcept { return false; }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    // It is not clear what it means for a boolean type to trap.
    // This is a DR on the LWG issue list.  Here, I use integer
    // promotion semantics.
    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<char> specialization.
template <>
struct numeric_limits<char>
{
    static constexpr bool is_specialized = true;

    static constexpr char
    min() noexcept { return __min(char); }

    static constexpr char
    max() noexcept { return __max(char); }

#if __cplusplus >= 201103L
    static constexpr char
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(char);
    static constexpr int digits10 = __digits10(char);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = __signed(char);
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr char
    epsilon() noexcept { return 0; }

    static constexpr char
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr char infinity() noexcept { return char(); }

    static constexpr char
    quiet_NaN() noexcept { return char(); }

    static constexpr char
    signaling_NaN() noexcept { return char(); }

    static constexpr char
    denorm_min() noexcept { return static_cast<char>(0); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<signed char> specialization.
template <>
struct numeric_limits<signed char>
{
    static constexpr bool is_specialized = true;

    static constexpr signed char
    min() noexcept { return -__SCHAR_MAX__ - 1; }

    static constexpr signed char
    max() noexcept { return __SCHAR_MAX__; }

#if __cplusplus >= 201103L
    static constexpr signed char
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(signed char);
    static constexpr int digits10 = __digits10(signed char);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr signed char
    epsilon() noexcept { return 0; }

    static constexpr signed char
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr signed char
    infinity() noexcept { return static_cast<signed char>(0); }

    static constexpr signed char
    quiet_NaN() noexcept { return static_cast<signed char>(0); }

    static constexpr signed char
    signaling_NaN() noexcept
    {
        return static_cast<signed char>(0);
    }

    static constexpr signed char
    denorm_min() noexcept
    {
        return static_cast<signed char>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<unsigned char> specialization.
template <>
struct numeric_limits<unsigned char>
{
    static constexpr bool is_specialized = true;

    static constexpr unsigned char
    min() noexcept { return 0; }

    static constexpr unsigned char
    max() noexcept { return __SCHAR_MAX__ * 2U + 1; }

#if __cplusplus >= 201103L
    static constexpr unsigned char
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(unsigned char);
    static constexpr int digits10 = __digits10(unsigned char);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned char
    epsilon() noexcept { return 0; }

    static constexpr unsigned char
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned char
    infinity() noexcept
    {
        return static_cast<unsigned char>(0);
    }

    static constexpr unsigned char
    quiet_NaN() noexcept
    {
        return static_cast<unsigned char>(0);
    }

    static constexpr unsigned char
    signaling_NaN() noexcept
    {
        return static_cast<unsigned char>(0);
    }

    static constexpr unsigned char
    denorm_min() noexcept
    {
        return static_cast<unsigned char>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<wchar_t> specialization.
template <>
struct numeric_limits<wchar_t>
{
    static constexpr bool is_specialized = true;

    static constexpr wchar_t
    min() noexcept { return __min(wchar_t); }

    static constexpr wchar_t
    max() noexcept { return __max(wchar_t); }

#if __cplusplus >= 201103L
    static constexpr wchar_t
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(wchar_t);
    static constexpr int digits10 = __digits10(wchar_t);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = __signed(wchar_t);
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr wchar_t
    epsilon() noexcept { return 0; }

    static constexpr wchar_t
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr wchar_t
    infinity() noexcept { return wchar_t(); }

    static constexpr wchar_t
    quiet_NaN() noexcept { return wchar_t(); }

    static constexpr wchar_t
    signaling_NaN() noexcept { return wchar_t(); }

    static constexpr wchar_t
    denorm_min() noexcept { return wchar_t(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

#if __cplusplus >= 201103L
/// numeric_limits<char16_t> specialization.
template <>
struct numeric_limits<char16_t>
{
    static constexpr bool is_specialized = true;

    static constexpr char16_t
    min() noexcept { return __min(char16_t); }

    static constexpr char16_t
    max() noexcept { return __max(char16_t); }

    static constexpr char16_t
    lowest() noexcept { return min(); }

    static constexpr int digits = __digits(char16_t);
    static constexpr int digits10 = __digits10(char16_t);
    static constexpr int max_digits10 = 0;
    static constexpr bool is_signed = __signed(char16_t);
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr char16_t
    epsilon() noexcept { return 0; }

    static constexpr char16_t
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr char16_t
    infinity() noexcept { return char16_t(); }

    static constexpr char16_t
    quiet_NaN() noexcept { return char16_t(); }

    static constexpr char16_t
    signaling_NaN() noexcept { return char16_t(); }

    static constexpr char16_t
    denorm_min() noexcept { return char16_t(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<char32_t> specialization.
template <>
struct numeric_limits<char32_t>
{
    static constexpr bool is_specialized = true;

    static constexpr char32_t
    min() noexcept { return __min(char32_t); }

    static constexpr char32_t
    max() noexcept { return __max(char32_t); }

    static constexpr char32_t
    lowest() noexcept { return min(); }

    static constexpr int digits = __digits(char32_t);
    static constexpr int digits10 = __digits10(char32_t);
    static constexpr int max_digits10 = 0;
    static constexpr bool is_signed = __signed(char32_t);
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr char32_t
    epsilon() noexcept { return 0; }

    static constexpr char32_t
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr char32_t
    infinity() noexcept { return char32_t(); }

    static constexpr char32_t
    quiet_NaN() noexcept { return char32_t(); }

    static constexpr char32_t
    signaling_NaN() noexcept { return char32_t(); }

    static constexpr char32_t
    denorm_min() noexcept { return char32_t(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};
#endif

/// numeric_limits<short> specialization.
template <>
struct numeric_limits<short>
{
    static constexpr bool is_specialized = true;

    static constexpr short
    min() noexcept { return -__SHRT_MAX__ - 1; }

    static constexpr short
    max() noexcept { return __SHRT_MAX__; }

#if __cplusplus >= 201103L
    static constexpr short
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(short);
    static constexpr int digits10 = __digits10(short);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr short
    epsilon() noexcept { return 0; }

    static constexpr short
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr short
    infinity() noexcept { return short(); }

    static constexpr short
    quiet_NaN() noexcept { return short(); }

    static constexpr short
    signaling_NaN() noexcept { return short(); }

    static constexpr short
    denorm_min() noexcept { return short(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<unsigned short> specialization.
template <>
struct numeric_limits<unsigned short>
{
    static constexpr bool is_specialized = true;

    static constexpr unsigned short
    min() noexcept { return 0; }

    static constexpr unsigned short
    max() noexcept { return __SHRT_MAX__ * 2U + 1; }

#if __cplusplus >= 201103L
    static constexpr unsigned short
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(unsigned short);
    static constexpr int digits10 = __digits10(unsigned short);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned short
    epsilon() noexcept { return 0; }

    static constexpr unsigned short
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned short
    infinity() noexcept
    {
        return static_cast<unsigned short>(0);
    }

    static constexpr unsigned short
    quiet_NaN() noexcept
    {
        return static_cast<unsigned short>(0);
    }

    static constexpr unsigned short
    signaling_NaN() noexcept
    {
        return static_cast<unsigned short>(0);
    }

    static constexpr unsigned short
    denorm_min() noexcept
    {
        return static_cast<unsigned short>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<int> specialization.
template <>
struct numeric_limits<int>
{
    static constexpr bool is_specialized = true;

    static constexpr int
    min() noexcept { return -__INT_MAX__ - 1; }

    static constexpr int
    max() noexcept { return __INT_MAX__; }

#if __cplusplus >= 201103L
    static constexpr int
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(int);
    static constexpr int digits10 = __digits10(int);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr int
    epsilon() noexcept { return 0; }

    static constexpr int
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr int
    infinity() noexcept { return static_cast<int>(0); }

    static constexpr int
    quiet_NaN() noexcept { return static_cast<int>(0); }

    static constexpr int
    signaling_NaN() noexcept { return static_cast<int>(0); }

    static constexpr int
    denorm_min() noexcept { return static_cast<int>(0); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<unsigned int> specialization.
template <>
struct numeric_limits<unsigned int>
{
    static constexpr bool is_specialized = true;

    static constexpr unsigned int
    min() noexcept { return 0; }

    static constexpr unsigned int
    max() noexcept { return __INT_MAX__ * 2U + 1; }

#if __cplusplus >= 201103L
    static constexpr unsigned int
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(unsigned int);
    static constexpr int digits10 = __digits10(unsigned int);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned int
    epsilon() noexcept { return 0; }

    static constexpr unsigned int
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned int
    infinity() noexcept { return static_cast<unsigned int>(0); }

    static constexpr unsigned int
    quiet_NaN() noexcept
    {
        return static_cast<unsigned int>(0);
    }

    static constexpr unsigned int
    signaling_NaN() noexcept
    {
        return static_cast<unsigned int>(0);
    }

    static constexpr unsigned int
    denorm_min() noexcept
    {
        return static_cast<unsigned int>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<long> specialization.
template <>
struct numeric_limits<long>
{
    static constexpr bool is_specialized = true;

    static constexpr long
    min() noexcept { return -__LONG_MAX__ - 1; }

    static constexpr long
    max() noexcept { return __LONG_MAX__; }

#if __cplusplus >= 201103L
    static constexpr long
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(long);
    static constexpr int digits10 = __digits10(long);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr long
    epsilon() noexcept { return 0; }

    static constexpr long
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr long
    infinity() noexcept { return static_cast<long>(0); }

    static constexpr long
    quiet_NaN() noexcept { return static_cast<long>(0); }

    static constexpr long
    signaling_NaN() noexcept { return static_cast<long>(0); }

    static constexpr long
    denorm_min() noexcept { return static_cast<long>(0); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<unsigned long> specialization.
template <>
struct numeric_limits<unsigned long>
{
    static constexpr bool is_specialized = true;

    static constexpr unsigned long
    min() noexcept { return 0; }

    static constexpr unsigned long
    max() noexcept { return __LONG_MAX__ * 2UL + 1; }

#if __cplusplus >= 201103L
    static constexpr unsigned long
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(unsigned long);
    static constexpr int digits10 = __digits10(unsigned long);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned long
    epsilon() noexcept { return 0; }

    static constexpr unsigned long
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned long
    infinity() noexcept
    {
        return static_cast<unsigned long>(0);
    }

    static constexpr unsigned long
    quiet_NaN() noexcept
    {
        return static_cast<unsigned long>(0);
    }

    static constexpr unsigned long
    signaling_NaN() noexcept
    {
        return static_cast<unsigned long>(0);
    }

    static constexpr unsigned long
    denorm_min() noexcept
    {
        return static_cast<unsigned long>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<long long> specialization.
template <>
struct numeric_limits<long long>
{
    static constexpr bool is_specialized = true;

    static constexpr long long
    min() noexcept { return -__LONG_LONG_MAX__ - 1; }

    static constexpr long long
    max() noexcept { return __LONG_LONG_MAX__; }

#if __cplusplus >= 201103L
    static constexpr long long
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(long long);
    static constexpr int digits10 = __digits10(long long);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr long long
    epsilon() noexcept { return 0; }

    static constexpr long long
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr long long
    infinity() noexcept { return static_cast<long long>(0); }

    static constexpr long long
    quiet_NaN() noexcept { return static_cast<long long>(0); }

    static constexpr long long
    signaling_NaN() noexcept
    {
        return static_cast<long long>(0);
    }

    static constexpr long long
    denorm_min() noexcept { return static_cast<long long>(0); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

/// numeric_limits<unsigned long long> specialization.
template <>
struct numeric_limits<unsigned long long>
{
    static constexpr bool is_specialized = true;

    static constexpr unsigned long long
    min() noexcept { return 0; }

    static constexpr unsigned long long
    max() noexcept { return __LONG_LONG_MAX__ * 2ULL + 1; }

#if __cplusplus >= 201103L
    static constexpr unsigned long long
    lowest() noexcept
    {
        return min();
    }
#endif

    static constexpr int digits = __digits(unsigned long long);
    static constexpr int digits10 = __digits10(unsigned long long);
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = 0;
#endif
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned long long
    epsilon() noexcept { return 0; }

    static constexpr unsigned long long
    round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned long long
    infinity() noexcept
    {
        return static_cast<unsigned long long>(0);
    }

    static constexpr unsigned long long
    quiet_NaN() noexcept
    {
        return static_cast<unsigned long long>(0);
    }

    static constexpr unsigned long long
    signaling_NaN() noexcept
    {
        return static_cast<unsigned long long>(0);
    }

    static constexpr unsigned long long
    denorm_min() noexcept
    {
        return static_cast<unsigned long long>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

#if !defined(__STRICT_ANSI__)

#define __INT_N(TYPE, BITSIZE, EXT, UEXT)                                   \
    template <>                                                             \
    struct numeric_limits<TYPE>                                             \
    {                                                                       \
        static constexpr bool is_specialized = true;                        \
                                                                            \
        static constexpr TYPE                                               \
        min() noexcept { return __min_b(TYPE, BITSIZE); }                   \
                                                                            \
        static constexpr TYPE                                               \
        max() noexcept { return __max_b(TYPE, BITSIZE); }                   \
                                                                            \
        static constexpr int digits = BITSIZE - 1;                          \
        static constexpr int digits10 = (BITSIZE - 1) * 643L / 2136;        \
                                                                            \
        static constexpr bool is_signed = true;                             \
        static constexpr bool is_integer = true;                            \
        static constexpr bool is_exact = true;                              \
        static constexpr int radix = 2;                                     \
                                                                            \
        static constexpr TYPE                                               \
        epsilon() noexcept { return 0; }                                    \
                                                                            \
        static constexpr TYPE                                               \
        round_error() noexcept { return 0; }                                \
                                                                            \
        EXT                                                                 \
                                                                            \
            static constexpr int min_exponent = 0;                          \
        static constexpr int min_exponent10 = 0;                            \
        static constexpr int max_exponent = 0;                              \
        static constexpr int max_exponent10 = 0;                            \
                                                                            \
        static constexpr bool has_infinity = false;                         \
        static constexpr bool has_quiet_NaN = false;                        \
        static constexpr bool has_signaling_NaN = false;                    \
        static constexpr float_denorm_style has_denorm = denorm_absent;     \
        static constexpr bool has_denorm_loss = false;                      \
                                                                            \
        static constexpr TYPE                                               \
        infinity() noexcept                                                 \
        {                                                                   \
            return static_cast<TYPE>(0);                                    \
        }                                                                   \
                                                                            \
        static constexpr TYPE                                               \
        quiet_NaN() noexcept                                                \
        {                                                                   \
            return static_cast<TYPE>(0);                                    \
        }                                                                   \
                                                                            \
        static constexpr TYPE                                               \
        signaling_NaN() noexcept                                            \
        {                                                                   \
            return static_cast<TYPE>(0);                                    \
        }                                                                   \
                                                                            \
        static constexpr TYPE                                               \
        denorm_min() noexcept                                               \
        {                                                                   \
            return static_cast<TYPE>(0);                                    \
        }                                                                   \
                                                                            \
        static constexpr bool is_iec559 = false;                            \
        static constexpr bool is_bounded = true;                            \
        static constexpr bool is_modulo = false;                            \
                                                                            \
        static constexpr bool traps = false;                                \
        static constexpr bool tinyness_before = false;                      \
        static constexpr float_round_style round_style = round_toward_zero; \
    };                                                                      \
                                                                            \
    template <>                                                             \
    struct numeric_limits<unsigned TYPE>                                    \
    {                                                                       \
        static constexpr bool is_specialized = true;                        \
                                                                            \
        static constexpr unsigned TYPE                                      \
        min() noexcept { return 0; }                                        \
                                                                            \
        static constexpr unsigned TYPE                                      \
        max() noexcept                                                      \
        {                                                                   \
            return __max_b(unsigned TYPE, BITSIZE);                         \
        }                                                                   \
                                                                            \
        UEXT                                                                \
                                                                            \
            static constexpr int digits = BITSIZE;                          \
        static constexpr int digits10 = BITSIZE * 643L / 2136;              \
        static constexpr bool is_signed = false;                            \
        static constexpr bool is_integer = true;                            \
        static constexpr bool is_exact = true;                              \
        static constexpr int radix = 2;                                     \
                                                                            \
        static constexpr unsigned TYPE                                      \
        epsilon() noexcept { return 0; }                                    \
                                                                            \
        static constexpr unsigned TYPE                                      \
        round_error() noexcept { return 0; }                                \
                                                                            \
        static constexpr int min_exponent = 0;                              \
        static constexpr int min_exponent10 = 0;                            \
        static constexpr int max_exponent = 0;                              \
        static constexpr int max_exponent10 = 0;                            \
                                                                            \
        static constexpr bool has_infinity = false;                         \
        static constexpr bool has_quiet_NaN = false;                        \
        static constexpr bool has_signaling_NaN = false;                    \
        static constexpr float_denorm_style has_denorm = denorm_absent;     \
        static constexpr bool has_denorm_loss = false;                      \
                                                                            \
        static constexpr unsigned TYPE                                      \
        infinity() noexcept                                                 \
        {                                                                   \
            return static_cast<unsigned TYPE>(0);                           \
        }                                                                   \
                                                                            \
        static constexpr unsigned TYPE                                      \
        quiet_NaN() noexcept                                                \
        {                                                                   \
            return static_cast<unsigned TYPE>(0);                           \
        }                                                                   \
                                                                            \
        static constexpr unsigned TYPE                                      \
        signaling_NaN() noexcept                                            \
        {                                                                   \
            return static_cast<unsigned TYPE>(0);                           \
        }                                                                   \
                                                                            \
        static constexpr unsigned TYPE                                      \
        denorm_min() noexcept                                               \
        {                                                                   \
            return static_cast<unsigned TYPE>(0);                           \
        }                                                                   \
                                                                            \
        static constexpr bool is_iec559 = false;                            \
        static constexpr bool is_bounded = true;                            \
        static constexpr bool is_modulo = true;                             \
                                                                            \
        static constexpr bool traps = false;                                \
        static constexpr bool tinyness_before = false;                      \
        static constexpr float_round_style round_style = round_toward_zero; \
    };

#if __cplusplus >= 201103L

#define __INT_N_201103(TYPE)            \
    static constexpr TYPE               \
    lowest() noexcept { return min(); } \
    static constexpr int max_digits10 = 0;

#define __INT_N_U201103(TYPE)           \
    static constexpr unsigned TYPE      \
    lowest() noexcept { return min(); } \
    static constexpr int max_digits10 = 0;

#else
#define __INT_N_201103(TYPE)
#define __INT_N_U201103(TYPE)
#endif

#ifdef __TYPE_INT_N_0
__INT_N(__TYPE_INT_N_0, __BITSIZE_INT_N_0,
        __INT_N_201103(__TYPE_INT_N_0), __INT_N_U201103(__TYPE_INT_N_0))
#endif
#ifdef __TYPE_INT_N_1
__INT_N(__TYPE_INT_N_1, __BITSIZE_INT_N_1,
        __INT_N_201103(__TYPE_INT_N_1), __INT_N_U201103(__TYPE_INT_N_1))
#endif
#ifdef __TYPE_INT_N_2
__INT_N(__TYPE_INT_N_2, __BITSIZE_INT_N_2,
        __INT_N_201103(__TYPE_INT_N_2), __INT_N_U201103(__TYPE_INT_N_2))
#endif
#ifdef __TYPE_INT_N_3
__INT_N(__TYPE_INT_N_3, __BITSIZE_INT_N_3,
        __INT_N_201103(__TYPE_INT_N_3), __INT_N_U201103(__TYPE_INT_N_3))
#endif

#undef __INT_N
#undef __INT_N_201103
#undef __INT_N_U201103

#endif

/// numeric_limits<float> specialization.
template <>
struct numeric_limits<float>
{
    static constexpr bool is_specialized = true;

    static constexpr float
    min() noexcept { return __FLT_MIN__; }

    static constexpr float
    max() noexcept { return __FLT_MAX__; }

#if __cplusplus >= 201103L
    static constexpr float
    lowest() noexcept
    {
        return -__FLT_MAX__;
    }
#endif

    static constexpr int digits = __FLT_MANT_DIG__;
    static constexpr int digits10 = __FLT_DIG__;
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = __max_digits10(__FLT_MANT_DIG__);
#endif
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int radix = __FLT_RADIX__;

    static constexpr float
    epsilon() noexcept { return __FLT_EPSILON__; }

    static constexpr float
    round_error() noexcept { return 0.5F; }

    static constexpr int min_exponent = __FLT_MIN_EXP__;
    static constexpr int min_exponent10 = __FLT_MIN_10_EXP__;
    static constexpr int max_exponent = __FLT_MAX_EXP__;
    static constexpr int max_exponent10 = __FLT_MAX_10_EXP__;

    static constexpr bool has_infinity = __FLT_HAS_INFINITY__;
    static constexpr bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr float_denorm_style has_denorm = bool(__FLT_HAS_DENORM__) ? denorm_present : denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr float
    infinity() noexcept { return __builtin_huge_valf(); }

    static constexpr float
    quiet_NaN() noexcept { return __builtin_nanf(""); }

    static constexpr float
    signaling_NaN() noexcept { return __builtin_nansf(""); }

    static constexpr float
    denorm_min() noexcept { return __FLT_DENORM_MIN__; }

    static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_to_nearest;
};

/// numeric_limits<double> specialization.
template <>
struct numeric_limits<double>
{
    static constexpr bool is_specialized = true;

    static constexpr double
    min() noexcept { return __DBL_MIN__; }

    static constexpr double
    max() noexcept { return __DBL_MAX__; }

#if __cplusplus >= 201103L
    static constexpr double
    lowest() noexcept
    {
        return -__DBL_MAX__;
    }
#endif

    static constexpr int digits = __DBL_MANT_DIG__;
    static constexpr int digits10 = __DBL_DIG__;
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = __max_digits10(__DBL_MANT_DIG__);
#endif
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int radix = __FLT_RADIX__;

    static constexpr double
    epsilon() noexcept { return __DBL_EPSILON__; }

    static constexpr double
    round_error() noexcept { return 0.5; }

    static constexpr int min_exponent = __DBL_MIN_EXP__;
    static constexpr int min_exponent10 = __DBL_MIN_10_EXP__;
    static constexpr int max_exponent = __DBL_MAX_EXP__;
    static constexpr int max_exponent10 = __DBL_MAX_10_EXP__;

    static constexpr bool has_infinity = __DBL_HAS_INFINITY__;
    static constexpr bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr float_denorm_style has_denorm = bool(__DBL_HAS_DENORM__) ? denorm_present : denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr double
    infinity() noexcept { return __builtin_huge_val(); }

    static constexpr double
    quiet_NaN() noexcept { return __builtin_nan(""); }

    static constexpr double
    signaling_NaN() noexcept { return __builtin_nans(""); }

    static constexpr double
    denorm_min() noexcept { return __DBL_DENORM_MIN__; }

    static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_to_nearest;
};

/// numeric_limits<long double> specialization.
template <>
struct numeric_limits<long double>
{
    static constexpr bool is_specialized = true;

    static constexpr long double
    min() noexcept { return __LDBL_MIN__; }

    static constexpr long double
    max() noexcept { return __LDBL_MAX__; }

#if __cplusplus >= 201103L
    static constexpr long double
    lowest() noexcept
    {
        return -__LDBL_MAX__;
    }
#endif

    static constexpr int digits = __LDBL_MANT_DIG__;
    static constexpr int digits10 = __LDBL_DIG__;
#if __cplusplus >= 201103L
    static constexpr int max_digits10 = __max_digits10(__LDBL_MANT_DIG__);
#endif
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int radix = __FLT_RADIX__;

    static constexpr long double
    epsilon() noexcept { return __LDBL_EPSILON__; }

    static constexpr long double
    round_error() noexcept { return 0.5L; }

    static constexpr int min_exponent = __LDBL_MIN_EXP__;
    static constexpr int min_exponent10 = __LDBL_MIN_10_EXP__;
    static constexpr int max_exponent = __LDBL_MAX_EXP__;
    static constexpr int max_exponent10 = __LDBL_MAX_10_EXP__;

    static constexpr bool has_infinity = __LDBL_HAS_INFINITY__;
    static constexpr bool has_quiet_NaN = __LDBL_HAS_QUIET_NAN__;
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr float_denorm_style has_denorm = bool(__LDBL_HAS_DENORM__) ? denorm_present : denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr long double
    infinity() noexcept { return __builtin_huge_vall(); }

    static constexpr long double
    quiet_NaN() noexcept { return __builtin_nanl(""); }

    static constexpr long double
    signaling_NaN() noexcept { return __builtin_nansl(""); }

    static constexpr long double
    denorm_min() noexcept { return __LDBL_DENORM_MIN__; }

    static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before =
        false;
    static constexpr float_round_style round_style =
        round_to_nearest;
};

} // namespace OS6STD

OS6STD_END_SYSTEM_HEADER

#endif

//=============================================================================
// End of file
//=============================================================================